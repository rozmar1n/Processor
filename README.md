# Набор инструментов для стекового процессора

## Состав проекта
- **Ассемблер (`my_compiler`)** — разбирает DSL из `tests/programs/` (или ваши скрипты) и генерирует бинарный код для виртуальной машины.
- **Процессор (`my_processor`)** — исполняет собранные бинарники, используя регистровый файл, оперативную память и защищённую реализацию стека.
- **Общие библиотеки** — текстовые утилиты à la «Онегин» и укреплённый стек (`src/common`), используемые обоими бинарями.

Недавно код прошёл капитальную чистку: стек корректно обрабатывает ошибки выделения, процессор проверяет заголовки бинарников перед запуском, таблица меток расширяется по необходимости, а модуль команд покрывает весь набор инструкций. Шумные отладочные принты убраны, а проверка конвейера опирается на быстрый сквозной smoke-тест.

## Структура репозитория
```
include/
  common/…   общие заголовки (инструкции, «онегин»-хелперы, стек)
  compiler/… API ассемблера
  processor/… API процессора
src/
  common/…   реализации общих модулей
  compiler/… логика ассемблера (два прохода, хранение меток)
  processor/… семантика команд и цикл VM
resources/programs/   примеры программ, бинарники и журналы
tests/programs/       небольшие DSL-скрипты для автотестов
tools/                вспомогательные утилиты (например, генератор круга)
```

## Сборка и тестирование
Требуются CMake ≥3.16 и компилятор с поддержкой C++17.
```bash
cmake -S . -B build
cmake --build build
ctest --test-dir build --output-on-failure
```
По умолчанию выполняются два теста CTest:
1. `compile_sample_program` — собирает `tests/programs/add.txt` во временный бинарник.
2. `run_sample_program` — запускает бинарник через `my_processor` и проверяет, что в stdout появляется `OUT: 5`.

## Использование
### Ассемблер
```bash
build/bin/my_compiler путь/к/исходнику.txt путь/к/выходу.bin
```
Если путь к выходному файлу не указан, бинарник сохраняется в `resources/programs/new_program.bin`. Ассемблер по-прежнему делает два прохода для разрешения меток; диагностика идёт в stderr и (при явном запросе) в `resources/programs/logfile.txt`.

### Процессор
```bash
build/bin/my_processor путь/к/программе.bin
```
Без аргументов процессор использует `resources/programs/new_program.bin`. Результаты (`out`/`print`) выводятся в stdout; при указании лог-файла трассировка команд записывается только туда.

### Генерация демо «круга»
```bash
build/bin/circle_generator
```
Интерактивный инструмент, который перезаписывает `resources/programs/circle.txt` сценарием отрисовки окружности.

## Известные ограничения и планы
- В процессоре много логики на `double`; переход на строгие структуры команд повысил бы надёжность.
- Обработка ошибок в ассемблере минимальна — синтаксические проблемы рушат второй проход.
- Помимо smoke-теста нет регрессионного покрытия; стоит добавить сценарии для прыжков, работы с памятью и некорректных бинарников.
- `StackDump` всё ещё пишет в `stderr`; имеет смысл перенаправить вывод в буфер или отдельный логгер.

## Советы по работе
- Для инкрементальной сборки используйте `cmake --build build --target my_compiler` (или нужную цель).
- Добавляя новые инструкции или синтаксис, расширяйте `tests/programs/` и `CMakeLists.txt`, чтобы CTest сразу покрывал изменения.
- В новом коде держите пути к ресурсам относительными от `PROJECT_SOURCE_DIR`, чтобы собирать проект вне исходного каталога.
